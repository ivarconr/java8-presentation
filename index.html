<!DOCTYPE html>
<html>
  <head>
    <title>Java 8: Project Lambda</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      /* Slideshow styles */
      @import url(lib/ubuntu.css);

      body {
        font-family: 'Ubuntu', sans-serif;
        font-size: 18px;
      }
      h1, h2, h3 {
        font-weight: 400;
        margin-bottom: 0;
      }
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle

# Java 8 :: Project Lambda
# λ

Ivar Conradi Østhus

ico@finn.no

---

# Java 8 - a few new (important) features

- **Lambda expressions**
 - *greater impact than generics in Java 1.5*
- **Stream API**
- **Default methods in interfaces**
- Compact Profiles
- Nashorn JavaScript Engine
- More annotations
- Parallel Array Sorting
- (new) Date & Time API
- Concurrency Updates
-   .
-   .
-   .
- **Scheduled for March 2014**


Complete list: http://openjdk.java.net/projects/jdk8/features


---
class: center, middle

# **Warning:**
# *a lot of code examples in this presentation!*

---

# Imperative style: for each element
    
```
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
```

```
//1: old loop
for(int i = 0; i < numbers.size(); i++) {
  System.out.println(i);
}
```


```
//2: enhanced for-loop
for(int n : numbers) {
  System.out.println(n);
}
```

<!--
- Very low level and we need to write all steps on the way
- Extra mutable garbage variables
- Must know **how** to iterate a list of elements
- Easy to introduce bugs
-->

---
# Declarative style: for each element

```
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);   
```

### 
```
public interface Iterable<T> {
  ...
  void forEach(Consumer<? super T> action);
  ...
}
```

### With annonymous inner class:
```
numbers.forEach(new Consumer<Integer>() {
  public void accept(Integer number) {
    System.out.println(number);
  }
});
```

### With lambda expression:
```
numbers.forEach((Integer n) -> System.out.println(n));
```


---
# Lambda: types

### **Single expression**
```
(Integer i) -> i * 2;
```

### **Statement block**
```
(int x, int y) -> { return x + y; }

//multiple lines of code
(int n) -> {
  int value = n*2;
  return value;
};
```

---
# Lambda: type inference
```
(Integer i) -> i * 2;

(i) -> i * 2;

i -> i*2;


//Multiple params
(int x, int y) -> x + y

(x, y) -> x + y
```

```
(final Integer i) -> i * 2;
```

---
# Reuse lambdas

```
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
```

### **Function**
```
public static Consumer<Integer> consumer() {
  return (Integer n) -> System.out.println(n);
} 

numbers.forEach(consumer());
```

### **Variabel**
```
public Consumer<Integer> consumer = (Integer n) -> System.out.println(n);

numbers.forEach(consumer);
```

---
# Method reference
```
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);

//Lambda
numbers.forEach(n -> System.out.println(n));

//Method reference
numbers.forEach(System.out::println);
```

---
# Lambda summary
```
(int x, int y) -> { return x + y; }
 
(x, y) -> x + y
 
x -> x + x
 
() -> x
 
```

### Notes:
- enable better libraries
- use lexical scoping
- effectively final


---
# Use of functional interface

Methods taking a *functional interface* will accept:

- an anonymous inner class
- a lambda expression
- a method reference

<!--
# We can use lambdas with methods which takes a *functional interface* as argument

Notater:
- Hva er functional interface?
- Bonus: existing libraries are now forward-compatible to lambdas
 - Libraries that never imagined lambdas still work with them!
 - Maintains significant investment in existing libraries
 - Fewer new concepts
- invokedynamic to capture lambda expressions

-->

---
# What is a functional interfaces?

```
@FunctionalInterface
public interface Predicate<T> {
  boolean test(T t);
}
```

- **one** abstract unimplemented methods
- optional @FunctionalInterface annotation
- already a lot of functional interfaces in java
- Java API will be full of functional interfaces

---
# Functional interfaces in the JDK

```
Counsumer<T> 
//takes an input T and performs an operation on it.

Supplier<T> 
//a kind of factory,  will return a new or existing instance.

Predicate<T>
//Checks if argument T satisfies a requirement.

Function<T, R> 
//Transform an argument from type T to type R.
```

---
class: center, middle
# The Java Stream API


---
# Task: Double and sum all even numbers

```
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
```

### Imperative solution
```
int sumOfDoubledEvenNbrs = 0;
for(int number : numbers) {
  if(number % 2 == 0) {
    sumOfDoubledEvenNbrs += number * 2;
  }
}
```

### Declarative solution
```
int sum = numbers.stream()
  .filter(n -> n % 2 == 0)
  .mapToInt(n -> n * 2)
  .sum();
```

---
# The Java Stream API

- Integration of lambda expression into the core Collection API's
- Streams are like iterators, yield elements for processing
- An abstraction for specifying aggregate computation on data set
- Why did they not just add filter, map etc directly on Java Collections?

- Can be paralell
- Can be infinite
- more concise 
- more readable
- more composable operations
- parallelizable

_Intention: replace loops for aggregate opterations_

Notater:
- vi har jo hatt dette i databaser en stund!
- løsning i Java 8: Stream (med hjelp av lambda)
- Stream pipelimes are like builders
 - ladd many intermediate ops, then execute pipeline ONCE
- Don't modify source during query!!

Fine prints:
- do NOT modify the source during query
- operation params must be stateless



### Sidenote: Pipes in linux
```bash
cat index.html | tr "[A-Z]" "[a-z]" | grep lambda | sort
```




---
# Source
- collections, arrays, generator functions, IO
- _can be infinite_

# Intermediate operations
- filter, map, flatMap, sorted, distinct, limit,...
- lazy: create new strams
- often use lambdas to transform or drop values
Notater:
gjør ikke faktisk arbeid, setter bare opp pipeline med operasjoner

# Terminal operation
- Aggregation / summary:
  - toArray, toList
  - reduce,
  - sum, min, max, count
  - anyMatch, allMatch
- iteration
  - forEach
- Searching
  - findFirst
  - findAny

- produces a result / side-effect
- _pulls_ values down the pipeline

---
# Stream: sources 

from Collections
```
Stream<Person> personStream = persons.stream();
```

from IO
```
Stream<String> lineStream = bufferedReader.lines();
 ```

Stream factories
```
//range
IntStream numbers = IntStream.range(0, 10);

//random numbers
DoubleStream randomDoubles = new Random().doubles();

IntStream randomInts = new Random().ints(0, 10);
```

Note:
The primitive streams are included for performance reasons

---
# Stream: intermediate operations
- returns a *Stream*, not elements 
- they are lazy

filter
```
Stream<Person> stream = persons.stream().filter(p -> p.getAge() > 17);
```

map
```
Stream<String> stream = persons.stream().map(Person::getName);
```

mapToInt
```
IntStream stream3 = persons.stream().mapToInt(Person::getAge);
```

---
# Stream: statefull intermediate operations
- harder to run in parallel
- Examples: 
 - limit
 - substream 
 - sorted
 - distinct

```
Stream<Person> sortedStream = persons.stream()
    .filter(p -> p.getAge() > 17)
    .sorted((p1, p2) -> p1.getAge() - p2.getAge());
```

---
# Stream: Terminal operations
- return non-stream elements
- eager: force evaluation of the stream


Task: Find the average age in Sandnes
```
OptionalDouble average = persons.stream()
    .filter(p -> p.getCity().getName().equals("Sandnes"))
    .mapToInt(p -> p.getAge())
    .average();
```
_(How would an imperative solution look like?)_

---
# Imperative solution
Task: Find the average age in Sandnes
```
int sum = 0;
int count = 0;
for(Person person : persons){
    if(person.getCity().getName().equals("Sandnes")) {
        sum += person.getAge();
        count ++;
    }
}
double averageAgeInSandnes = (double)sum / count;
```

The Stream solution:
```
OptionalDouble average = persons.stream()
    .filter(p -> p.getCity().getName().equals("Sandnes"))
    .mapToInt(p -> p.getAge())
    .average();
```


---
# Stream: Collector
- aggregate values in to a container
- many predefined collectors in `java.util.stream.Collectors`
 - counting
 - averaging/summarizing/sum/min
 - toList/toMap/toSet
 - reducing
 - groupingBy
 - mapping 

Collectors.toSet()
```
Set<String> names = persons.stream()
  .map(Person::getName)
  .collect(toSet());
```

Resultat:
```
[Ivar Østhus, Donald Duck, Ola Hansen, Kari Normann, Silje Hansen, 
Knerten Lillebror]
```

---
# Stream: Collector


Collectors.groupingBy: age
```
Map<Integer, List<Person>> personsByAge =
    persons.stream().collect(groupingBy(Person::getAge));
```

groupingBy age, and only get their names
```
Map<Integer, List<String>> peopleByAge = 
  persons.stream()
    .collect(groupingBy(Person::getAge, mapping(Person::getName, toList())));
```

groupingByAge, and only count elements in group
```
Map<Integer, Long> ages = 
  persons.stream()
    .collect(groupingBy(Person::getAge, counting()));
```
```
{16=1, 32=1, 28=2, 12=1, 29=1}
```

---
# Collector: joining
# droppes?

```
persons.stream()
  .filter(p -> p.getAge() > 18)
  .sorted((p1, p2) -> p1.getAge() - p2.getAge())
  .map(p -> p.getAge() + ":" + p.getName())
  .collect(Collectors.joining(", "));
```

Output:
```
21:Ola Hansen, 28:Ivar Østhus, 29:Kari Normann, 42:Donald Duck
```

---
# Stream the contents of a CSV file

*Map persons in a CSV to a list of persons and return the 50 first adults. *

```csv
name, age, city, country
Ivar Østhus, 28, Oslo, Norway
Viswanathan Anand, 43, Mayiladuthurai, India
Magnus Carlsen, 22, Tønsberg, Norway
...
```

**Solution:**
```
InputStream is = new FileInputStream(new File("persons.csv"));
BufferedReader br = new BufferedReader(new InputStreamReader(is));
 
List<Person> persons = br.lines()
    .substream(1)
    .map(toPerson)
    .filter(isAdult)
    .limit(50)
    .collect(toList());
```

lambdas:
```
public static Function<String, Person> toPerson = (line) -> {
  String[] p = line.split(", ");
  return new Person(p[0], Integer.parseInt(p[1]), p[2], p[3]);
};
public static Predicate<Person> isAdult = p -> p.getAge() > 17;
```


---
# Parallel Streams
- A behavioral parameter (lambda) may be invoked concurrently
- Must not access any state that might change during the operation
- This constraint gives us “wiggle room” to optimize
- fork/join from java7 under the hood
- order not guaranteed

```
//Sequential
OptionalDouble average = persons.stream()
    .filter(p -> p.getCity().getName().equals("Sandnes"))
    .mapToInt(p -> p.getAge())
    .average();

//Parallel
OptionalDouble average = persons.parallelStream()
    .filter(p -> p.getCity().getName().equals("Sandnes"))
    .mapToInt(p -> p.getAge())
    .average();
```

---
# Parallel Streams: visual model

![Parallel Streams](img/parallelSteam.png)

Notater:
PS = Always more work, but might take less time
For small and simple problems, sequential is usually still faster
lambda kan bare akksessere "effective final vars"

(Source: https://oracleus.activeevents.com/2013/connect/sessionDetail.ww?SESSION_ID=7942)

---
# Parallel Streams: Awesome FINN example
```Java
List<Long> awsomeFinnAdIds = awesomeAdService.fetchAwsomeAds();

List<Ads> awesomeFinnAds = awsomeFinnAdIds.parallelStream()
  .map(adService::fetchAd)
  .filter(ad -> ad.isActive())
  .collect(toList());
```

---
# Parallel Streams: Performance

Notes (should be structured better):
- Should I go parallel?
- Do not assume parallel is always faster!
 - Going parallel is easy, but not always the right thing to do
- Qualitative considerations
 - How good is the stream source decomposition?
 - Does the terminal operation have a cheap or expensive merge step?
- What are the stream characteristics?
 - The primitive streams are included for performance reasons
 - Boxing hurts performance
- For small data sets, sequential usually wins
- Complex pipelines are harder to reason about
- MEASURE!

## Simple performance model:
```
N = size of source data set
Q = cost per-element through the pipeline
N * Q ~= cost of pipeline
```
- Larger N * Q → higher chance of good parallel performance
- Gnererally it is easier to know N



---
# default methods
- A clever way to enhance exisiting interfaces

- Java Collections Framework, having been designed fifteen years ago for a language without a functional orientation, do not have a method forEach, or any of the other methods that this strategy will require.
- until now adding new methods to an interface has been impossible without forcing modification to existing classes
- This is the rationale for the introduction of default methods (also called virtual extension methods or defender methods).
- not break existing collections in Java
- any interface can contain one ore more concrete methods
- can be re-implemented


```
interface Iterator {
  // existing method declarations
  default void skip() {
      if (hasNext()) next();
  }
}
```

---
# Stream API: summary
- **Sources:** Collections, Generator functions, IO
- **Intermediate functions:** filter, map, sorted
- **Terminal operations:** sum, max, min, collect, groupingBy

---
# References:
- books: 
Functional Programming in Java - Vankat Subramaniam


- presentations:



    </textarea>
    <script src="lib/remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine;
      var slideshow = remark.create({
        highlightStyle: 'sunburst',
        highlightLanguage: 'java' 
      });
    </script>
  </body>
</html>